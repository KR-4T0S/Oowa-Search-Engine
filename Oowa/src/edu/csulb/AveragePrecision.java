package edu.csulb;

import cecs429.documents.DocumentCorpus;
import cecs429.index.Accumulator;
import cecs429.index.Index;
import cecs429.index.OperationWeightDefault;
import cecs429.index.OperationWeightOkapi;
import cecs429.index.OperationWeightTFIDF;
import cecs429.index.OperationWeightWacky;
import cecs429.index.Posting;
import cecs429.index.WeightStrategy;
import cecs429.index.WeightStrategyContext;
import cecs429.text.SimpleTokenProcessor;
import cecs429.text.TokenProcessor;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.HashSet;

import static edu.csulb.Oowa.ANSI_ITALIC;
import static edu.csulb.Oowa.ANSI_RESET;
import static edu.csulb.Oowa.MAX_RANKED_RESULTS_MAP;
import static edu.csulb.Oowa.WEIGHT_OKAPI;
import static edu.csulb.Oowa.WEIGHT_TRADITIONAL;
import static edu.csulb.Oowa.WEIGHT_WACKY;

public class AveragePrecision {
    
    private String mQuery;
    private Index mIndex;
    private DocumentCorpus mCorpus;
    private String mWeightMode;
    private HashSet mRelIds;
    private double mResponseTime;
    
    public AveragePrecision(String query, Index index, DocumentCorpus corpus, String weightMode, HashSet relIds) {
        mQuery = query;
        mIndex = index;
        mCorpus = corpus;
        mWeightMode = weightMode;
        mRelIds = relIds;
        mResponseTime = 0;
    }
    
    public double getAveragePrecision() {
        // Get results for current query & weight mode.
        //      this returns a maximum of 50 ranked postings
        List<Posting> rankedResults = getResultsRanked();
        
        double relSum = 0; // Sumation of relevances for calculating AP(q)
        int relCount = 0; // Number of relevant postings
        int i = 1;
        for (Posting p: rankedResults) {
            // Runtime ID: automatically generated by program
            // File ID: grabbed from file 'id' field.
            //      this is the id we need to compare with the rel file
            
            //  Instead of P@i returning 1:0, it's a boolean to decide
            //      whether this Posting needs to be considered in the sum.
            if (relevant(mCorpus.getDocument(p.getDocumentId()).getFileID(), mRelIds)) {
                relCount++; // Increase total # of relevant for O(1) PatI calculation
                double PatI = (double) relCount / (double) i; // P@i = (Total Relevant up to i) / i 
                
                // Print results for analysis.
                System.out.println(ANSI_ITALIC + "\t\t|\tRelevant: " + mCorpus.getDocument(p.getDocumentId()).getFileID() + ".json at index " + i + ANSI_RESET);
                System.out.println(ANSI_ITALIC + "\t\t|\t\tP@" + i + ": " + PatI + ANSI_RESET);
                
                // Add P@i to Relevance Sum
                relSum += (double) PatI;
            }
            i++;
        }
        
        //  (1 / |REL| ) * Sum(relevant (i) * P@i)
        double AP_q = 0;
        if (!mRelIds.isEmpty()) { // we don't want to divide by 0
            AP_q = ( 1.0 / (double) mRelIds.size() ) * (double) relSum;
        }
        
        return AP_q;
    }
    
    public double getResponseTime() {
        return mResponseTime;
    }
    
    private List<Posting> getResultsRanked() {
        List<Posting> result = new ArrayList();
        
        TokenProcessor tokenProcessor = new SimpleTokenProcessor();
        WeightStrategy strategy = null;

        // Just consider terms by space character.
        String[] terms = mQuery.split("\\s+");

        // Heap for results.
        PriorityQueue<Accumulator> heap = new PriorityQueue(); 
        
        // Use strategy depending on weightMode param
        switch(mWeightMode) {
            case (WEIGHT_TRADITIONAL):
                strategy = new OperationWeightTFIDF();
                break;
            case (WEIGHT_OKAPI):
                strategy = new OperationWeightOkapi();
                break;
            case (WEIGHT_WACKY):
                strategy = new OperationWeightWacky();
                break;
            default:
                strategy = new OperationWeightDefault();               
        }
        
        try {
            WeightStrategyContext context = new WeightStrategyContext(strategy);
            
            double startTimeQuery = System.currentTimeMillis(); // start time to log Response Time
            
            heap = context.get(mIndex, tokenProcessor, mCorpus.getCorpusSize(), terms); // get result
            
            
            // Either get MAX results if heap has that or more.
            // or just as many results as heap contains.
            int K = Math.min(MAX_RANKED_RESULTS_MAP, heap.size());
            for (int i = 0; i < K; i++) {
                Accumulator acc = heap.poll(); // Pop and Get greatest value from heap.
                Posting p = acc.getPosting(); // Retrieve Posting from the Accumulator
                result.add(p);
            }
            
            double endTimeQuery = System.currentTimeMillis(); // end time to log Response time
            mResponseTime = endTimeQuery - startTimeQuery; // calculate response time to retrieve ranked results
        } catch (Exception e) {
            System.out.println("\u001B[31m" + e + "\u001B[0m");
        }
        
        return result;
    }
    
    private boolean relevant(int i, HashSet rel) {
        return rel.contains(i);
    }
}
