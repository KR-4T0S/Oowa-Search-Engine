package edu.csulb;

import cecs429.documents.DocumentCorpus;
import cecs429.index.Accumulator;
import cecs429.index.Index;
import cecs429.index.OperationWeightDefault;
import cecs429.index.OperationWeightOkapi;
import cecs429.index.OperationWeightTFIDF;
import cecs429.index.OperationWeightWacky;
import cecs429.index.Posting;
import cecs429.index.WeightStrategy;
import cecs429.index.WeightStrategyContext;
import cecs429.text.SimpleTokenProcessor;
import cecs429.text.TokenProcessor;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.HashSet;

import static edu.csulb.Oowa.MAX_RANKED_RESULTS;
import static edu.csulb.Oowa.WEIGHT_OKAPI;
import static edu.csulb.Oowa.WEIGHT_TRADITIONAL;
import static edu.csulb.Oowa.WEIGHT_WACKY;

public class AveragePrecision {
    
    private String mQuery;
    private Index mIndex;
    private DocumentCorpus mCorpus;
    private String mWeightMode;
    private HashSet mRelIds;
    private double mResponseTime;
    
    public AveragePrecision(String query, Index index, DocumentCorpus corpus, String weightMode, HashSet relIds) {
        mQuery = query;
        mIndex = index;
        mCorpus = corpus;
        mWeightMode = weightMode;
        mRelIds = relIds;
        mResponseTime = 0;
    }
    
    public double getAveragePrecision() {
        List<Posting> rankedResults = getResultsRanked();
        
        double relSum = 0;
        int relCount = 0;
        int i = 1;
        for (Posting p: rankedResults) {
            // Runtime ID: automatically generated by program
            // File ID: grabbed from file 'id' field.
            //      this is the id we need to compare with the rel file
            if (relevant(mCorpus.getDocument(p.getDocumentId()).getFileID(), mRelIds)) {
                relCount++;
                //System.out.println("\t\t\tRelevant: " + mCorpus.getDocument(p.getDocumentId()).getFileID() + " at index " + i);
                double PatI = (double) relCount / (double) i;
                //System.out.println("\t\t\t\tP@" + i + ": " + PatI);
                relSum += (1.0 * (double) PatI);
            }
            i++;
        }
        
        //  (1 / |REL| ) * Sum(relevant (i) * P@i)
        double AP_q = 0;
        if (!rankedResults.isEmpty()) {
            AP_q = ( 1.0 / (double) rankedResults.size() ) * (double) relSum;
        }
        
        return AP_q;
    }
    
    public double getResponseTime() {
        return mResponseTime;
    }
    
    private List<Posting> getResultsRanked() {
        List<Posting> result = new ArrayList();
        
        TokenProcessor tokenProcessor = new SimpleTokenProcessor();
        WeightStrategy strategy = null;

        // Just consider terms by space character.
        String[] terms = mQuery.split("\\s+");

        // Heap for results.
        PriorityQueue<Accumulator> results = new PriorityQueue(); 
        
        // Use strategy depending on weightMode param
        switch(mWeightMode) {
            case (WEIGHT_TRADITIONAL):
                strategy = new OperationWeightTFIDF();
                break;
            case (WEIGHT_OKAPI):
                strategy = new OperationWeightOkapi();
                break;
            case (WEIGHT_WACKY):
                strategy = new OperationWeightWacky();
                break;
            default:
                strategy = new OperationWeightDefault();               
        }
        
        try {
            WeightStrategyContext context = new WeightStrategyContext(strategy);
            
            double startTimeQuery = System.currentTimeMillis();
            results = context.get(mIndex, tokenProcessor, mCorpus.getCorpusSize(), terms);
            double endTimeQuery = System.currentTimeMillis();
            mResponseTime = endTimeQuery - startTimeQuery;
            
            // Either print MAX results if heap has that or more.
            // or just as many results as heap contains.
            int K = Math.min(MAX_RANKED_RESULTS, results.size());
            for (int i = 0; i < K; i++) {
                Accumulator acc = results.poll(); // Pop and Get greatest value from heap.
                Posting p = acc.getPosting(); // Retrieve Posting from the Accumulator
                result.add(p);
            }
        } catch (Exception e) {
            System.out.println("\u001B[31m" + e + "\u001B[0m");
        }
        
        return result;
    }
    
    private boolean relevant(int i, HashSet rel) {
        return rel.contains(i);
    }
}
